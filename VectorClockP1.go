package main

import "fmt"
import "math/rand"
import "os"
import "strconv"
import "sync"
import "time"


var numProcesses, done int
var lock sync.Mutex
var vectorChannels []chan []int
var finishChannels []chan bool 
var finalStamps []chan []int


func vClock(b chan bool, receive chan []int, send chan int, pID int) {
	var vectorTS = make([]int, numProcesses) //The monitered process's vector timestamp
	var eventpID int = 0
	for {
		select {
		case vec := <-receive:
			//Recv message from other process
			//Increment own clock, set the timestamp of this process as TS[k] = max(TS[k], MTS[k])
			vectorTS[pID]++
			if vec[0] != -1 {
				fmt.Println("Process",pID,"received message")
				for i := 0; i < numProcesses; i++ {
					if vec[i] > vectorTS[i] {
						vectorTS[i] = vec[i]
					}
				}
			} else {
				fmt.Println("Process",pID,"event",eventpID,"timestamp:",vectorTS)
				eventpID++
			}	
		case dest := <-send:
			//Send timestamp
			vectorTS[pID]++
			fmt.Println("Process",pID,"event",eventpID,"timestamp:",vectorTS)
			eventpID++
			vectorChannels[dest] <- vectorTS
		case <-b:
			//Termination signal received, send timestamp to finalStamps channel and exit loop
			finalStamps[pID] <- vectorTS
			break
		}
	}
}

func process(pID int) { //processId
	
	var sendChan = make(chan int, 2)
	var epID int = 0

	//manages vectors
	go vClock(finishChannels[pID], vectorChannels[pID], sendChan, pID)

	//Locks so 1 process at a time is run
	lock.Lock();
	fmt.Println("Process", pID, "start")

	var dest int

	for i := 0; i < rand.Intn(10); i++ {
		time.Sleep(time.Second * time.Duration(1))
		if rand.Intn(50)%2 == 0 { //internal event
			fmt.Println("Internal event generated by process ", pID)
			vectorChannels[pID] <- []int{-1}

		} else {
			dest = rand.Intn(numProcesses)
			for dest == pID {
				dest = rand.Intn(numProcesses)
			}
			fmt.Println("Process", pID, " sending message to process ", dest)
			sendChan <- dest
		}
		epID++
	}

	//unlock
	done++
	fmt.Println("Process", pID, "done")
	lock.Unlock()

	if done == numProcesses {
		for k := 0; k < numProcesses; k++ {
			finishChannels[k] <- true
		}
	}
}

func main() {

	//Get and parse command line argument
	if len(os.Args) != 2 {
		fmt.Println("Invocation error. Must use executable file and invoke as: VectorClocks <pID_processes>")
		os.Exit(-1)
	}

	var err error
	numProcesses, err = strconv.Atoi(os.Args[1])
	if err != nil || numProcesses < 2 {
		fmt.Println("Argument error, must be a positive integer > 2")
		os.Exit(-1)
	}

	done = 0
	vectorChannels = make([]chan []int, numProcesses)
	finishChannels = make([]chan bool, numProcesses)
	finalStamps = make([]chan []int, numProcesses)

	for i := 0; i < numProcesses; i++ {
		vectorChannels[i] = make(chan []int, 10*numProcesses)
		finishChannels[i] = make(chan bool, numProcesses)
		finalStamps[i] = make(chan []int, numProcesses)
	}

	//Run all processes
	for j := 0; j < numProcesses; j++ {
		go process(j)
	}

	for k := 0; k < numProcesses; k++ {
		<- finalStamps[k]
	}	

	fmt.Println("All processes are finished")
}
